{"version":3,"file":"intersection-observer.js","sources":["../src/intersection-observer.js"],"sourcesContent":["/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n(function(window, document) {\n'use strict';\n\n\n// Exits early if all IntersectionObserver and IntersectionObserverEntry\n// features are natively supported.\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n  return;\n}\n\n\n// Use :root element of the document for .contains() calls because older IEs\n// support Node.prototype.contains only on Element nodes.\nvar docElement = document.documentElement;\n\n/**\n * An IntersectionObserver registry. This registry exists to hold a strong\n * reference to IntersectionObserver instances currently observering a target\n * element. Without this registry, instances without another reference may be\n * garbage collected.\n */\nvar registry = [];\n\n\n/**\n * Creates the global IntersectionObserverEntry constructor.\n * https://wicg.github.io/IntersectionObserver/#intersection-observer-entry\n * @param {Object} entry A dictionary of instance properties.\n * @constructor\n */\nfunction IntersectionObserverEntry(entry) {\n  this.time = entry.time;\n  this.target = entry.target;\n  this.rootBounds = entry.rootBounds;\n  this.boundingClientRect = entry.boundingClientRect;\n  this.intersectionRect = entry.intersectionRect || getEmptyRect();\n  this.isIntersecting = !!entry.intersectionRect;\n\n  // Calculates the intersection ratio. Sets it to 0 if the target area is 0.\n  var targetRect = this.boundingClientRect;\n  var targetArea = targetRect.width * targetRect.height;\n  var intersectionRect = this.intersectionRect;\n  var intersectionArea = intersectionRect.width * intersectionRect.height;\n  this.intersectionRatio = targetArea ? (intersectionArea / targetArea) : 0;\n}\n\n\n/**\n * Creates the global IntersectionObserver constructor.\n * https://wicg.github.io/IntersectionObserver/#intersection-observer-interface\n * @param {Function} callback The function to be invoked after intersection\n *     changes have queued. The function is not invoked if the queue has\n *     been emptied by calling the `takeRecords` method.\n * @param {Object=} opt_options Optional configuration options.\n * @constructor\n */\nfunction IntersectionObserver(callback, opt_options) {\n\n  var options = opt_options || {};\n\n  if (typeof callback != 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  if (options.root && options.root.nodeType != 1) {\n    throw new Error('root must be an Element');\n  }\n\n  // Binds and throttles `this._checkForIntersections`.\n  this._checkForIntersections = throttle(\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\n\n  // Private properties.\n  this._callback = callback;\n  this._observationTargets = [];\n  this._queuedEntries = [];\n  this._rootMarginValues = this._parseRootMargin(options.rootMargin);\n\n  // Public properties.\n  this.thresholds = this._initThresholds(options.threshold);\n  this.root = options.root || null;\n  this.rootMargin = this._rootMarginValues.map(function(margin) {\n    return margin.value + margin.unit;\n  }).join(' ');\n}\n\n\n/**\n * The minimum interval within which the document will be checked for\n * intersection changes.\n */\nIntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\n\n\n/**\n * The frequency in which the polyfill polls for intersection changes.\n * this can be updated on a per instance basis and must be set prior to\n * calling `observe` on the first target.\n */\nIntersectionObserver.prototype.POLL_INTERVAL = null;\n\n\n/**\n * Starts observing a target element for intersection changes based on\n * the thresholds values.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.observe = function(target) {\n  // If the target is already being observed, do nothing.\n  if (this._observationTargets.some(function(item) {\n    return item.element == target;\n  })) {\n    return;\n  }\n\n  if (!(target && target.nodeType == 1)) {\n    throw new Error('target must be an Element');\n  }\n\n  this._registerInstance();\n  this._observationTargets.push({element: target, entry: null});\n  this._monitorIntersections();\n};\n\n\n/**\n * Stops observing a target element for intersection changes.\n * @param {Element} target The DOM element to observe.\n */\nIntersectionObserver.prototype.unobserve = function(target) {\n  this._observationTargets =\n      this._observationTargets.filter(function(item) {\n\n    return item.element != target;\n  });\n  if (!this._observationTargets.length) {\n    this._unmonitorIntersections();\n    this._unregisterInstance();\n  }\n};\n\n\n/**\n * Stops observing all target elements for intersection changes.\n */\nIntersectionObserver.prototype.disconnect = function() {\n  this._observationTargets = [];\n  this._unmonitorIntersections();\n  this._unregisterInstance();\n};\n\n\n/**\n * Returns any queue entries that have not yet been reported to the\n * callback and clears the queue. This can be used in conjunction with the\n * callback to obtain the absolute most up-to-date intersection information.\n * @return {Array} The currently queued entries.\n */\nIntersectionObserver.prototype.takeRecords = function() {\n  var records = this._queuedEntries.slice();\n  this._queuedEntries = [];\n  return records;\n};\n\n\n/**\n * Accepts the threshold value from the user configuration object and\n * returns a sorted array of unique threshold values. If a value is not\n * between 0 and 1 and error is thrown.\n * @private\n * @param {Array|number=} opt_threshold An optional threshold value or\n *     a list of threshold values, defaulting to [0].\n * @return {Array} A sorted list of unique and valid threshold values.\n */\nIntersectionObserver.prototype._initThresholds = function(opt_threshold) {\n  var threshold = opt_threshold || [0];\n  if (!Array.isArray(threshold)) threshold = [threshold];\n\n  return threshold.sort().filter(function(t, i, a) {\n    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\n      throw new Error('threshold must be a number between 0 and 1 inclusively');\n    }\n    return t !== a[i - 1];\n  });\n};\n\n\n/**\n * Accepts the rootMargin value from the user configuration object\n * and returns an array of the four margin values as an object containing\n * the value and unit properties. If any of the values are not properly\n * formatted or use a unit other than px or %, and error is thrown.\n * @private\n * @param {string=} opt_rootMargin An optional rootMargin value,\n *     defaulting to '0px'.\n * @return {Array<Object>} An array of margin objects with the keys\n *     value and unit.\n */\nIntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\n  var marginString = opt_rootMargin || '0px';\n  var margins = marginString.split(/\\s+/).map(function(margin) {\n    var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n    if (!parts) {\n      throw new Error('rootMargin must be specified in pixels or percent');\n    }\n    return {value: parseFloat(parts[1]), unit: parts[2]};\n  });\n\n  // Handles shorthand.\n  margins[1] = margins[1] || margins[0];\n  margins[2] = margins[2] || margins[0];\n  margins[3] = margins[3] || margins[1];\n\n  return margins;\n};\n\n\n/**\n * Starts polling for intersection changes if the polling is not already\n * happening, and if the page's visibilty state is visible.\n * @private\n */\nIntersectionObserver.prototype._monitorIntersections = function() {\n  if (!this._monitoringIntersections) {\n    this._monitoringIntersections = true;\n\n    this._checkForIntersections();\n\n    // If a poll interval is set, use polling instead of listening to\n    // resize and scroll events or DOM mutations.\n    if (this.POLL_INTERVAL) {\n      this._monitoringInterval = setInterval(\n          this._checkForIntersections, this.POLL_INTERVAL);\n    }\n    else {\n      addEvent(window, 'resize', this._checkForIntersections, true);\n      addEvent(document, 'scroll', this._checkForIntersections, true);\n\n      if ('MutationObserver' in window) {\n        this._domObserver = new MutationObserver(this._checkForIntersections);\n        this._domObserver.observe(document, {\n          attributes: true,\n          childList: true,\n          characterData: true,\n          subtree: true\n        });\n      }\n    }\n  }\n};\n\n\n/**\n * Stops polling for intersection changes.\n * @private\n */\nIntersectionObserver.prototype._unmonitorIntersections = function() {\n  if (this._monitoringIntersections) {\n    this._monitoringIntersections = false;\n\n    clearInterval(this._monitoringInterval);\n    this._monitoringInterval = null;\n\n    removeEvent(window, 'resize', this._checkForIntersections, true);\n    removeEvent(document, 'scroll', this._checkForIntersections, true);\n\n    if (this._domObserver) {\n      this._domObserver.disconnect();\n      this._domObserver = null;\n    }\n  }\n};\n\n\n/**\n * Scans each observation target for intersection changes and adds them\n * to the internal entries queue. If new entries are found, it\n * schedules the callback to be invoked.\n * @private\n */\nIntersectionObserver.prototype._checkForIntersections = function() {\n  var rootIsInDom = this._rootIsInDom();\n  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\n\n  this._observationTargets.forEach(function(item) {\n    var target = item.element;\n    var targetRect = getBoundingClientRect(target);\n    var rootContainsTarget = this._rootContainsTarget(target);\nrootContainsTarget = true;\n    var oldEntry = item.entry;\n    var intersectionRect = rootIsInDom && rootContainsTarget &&\n        this._computeTargetAndRootIntersection(target, rootRect);\n\n    var newEntry = item.entry = new IntersectionObserverEntry({\n      time: now(),\n      target: target,\n      boundingClientRect: targetRect,\n      rootBounds: rootRect,\n      intersectionRect: intersectionRect\n    });\n\n// console.log(rootIsInDom, rootContainsTarget, newEntry);\n\n    if (rootIsInDom && rootContainsTarget) {\n      // If the new entry intersection ratio has crossed any of the\n      // thresholds, add a new entry.\n      if (this._hasCrossedThreshold(oldEntry, newEntry)) {\n        this._queuedEntries.push(newEntry);\n      }\n    } else {\n      // If the root is not in the DOM or target is not contained within\n      // root but the previous entry for this target had an intersection,\n      // add a new record indicating removal.\n      if (oldEntry && oldEntry.isIntersecting) {\n        this._queuedEntries.push(newEntry);\n      }\n    }\n  }, this);\n\n  if (this._queuedEntries.length) {\n    this._callback(this.takeRecords(), this);\n  }\n};\n\n\n/**\n * Accepts a target and root rect computes the intersection between then\n * following the algorithm in the spec.\n * TODO(philipwalton): at this time clip-path is not considered.\n * https://wicg.github.io/IntersectionObserver/#calculate-intersection-rect-algo\n * @param {Element} target The target DOM element\n * @param {Object} rootRect The bounding rect of the root after being\n *     expanded by the rootMargin value.\n * @return {?Object} The final intersection rect object or undefined if no\n *     intersection is found.\n * @private\n */\nIntersectionObserver.prototype._computeTargetAndRootIntersection =\n    function(target, rootRect) {\n\n  // If the element isn't displayed, an intersection can't happen.\n  if (window.getComputedStyle(target).display == 'none') return;\n\n  var targetRect = getBoundingClientRect(target);\n  var intersectionRect = targetRect;\n  var parent = target.parentNode;\n  var atRoot = false;\n\n  while (!atRoot) {\n    var parentRect = null;\n\n    // If we're at the root element, set parentRect to the already\n    // calculated rootRect.\n    if (parent == this.root || parent.nodeType != 1) {\n      atRoot = true;\n      parentRect = rootRect;\n    }\n    // Otherwise check to see if the parent element hides overflow,\n    // and if so update parentRect.\n    else {\n      if (window.getComputedStyle(parent).overflow != 'visible') {\n        parentRect = getBoundingClientRect(parent);\n      }\n    }\n    // If either of the above conditionals set a new parentRect,\n    // calculate new intersection data.\n    if (parentRect) {\n      intersectionRect = computeRectIntersection(parentRect, intersectionRect);\n\n      if (!intersectionRect) break;\n    }\n    parent = parent.parentNode;\n  }\n  return intersectionRect;\n};\n\n\n/**\n * Returns the root rect after being expanded by the rootMargin value.\n * @return {Object} The expanded root rect.\n * @private\n */\nIntersectionObserver.prototype._getRootRect = function() {\n  var rootRect;\n  if (this.root) {\n    rootRect = getBoundingClientRect(this.root);\n  } else {\n    // Use <html>/<body> instead of window since scroll bars affect size.\n    var html = document.documentElement;\n    var body = document.body;\n    rootRect = {\n      top: 0,\n      left: 0,\n      right: html.clientWidth || body.clientWidth,\n      width: html.clientWidth || body.clientWidth,\n      bottom: html.clientHeight || body.clientHeight,\n      height: html.clientHeight || body.clientHeight\n    };\n  }\n  return this._expandRectByRootMargin(rootRect);\n};\n\n\n/**\n * Accepts a rect and expands it by the rootMargin value.\n * @param {Object} rect The rect object to expand.\n * @return {Object} The expanded rect.\n * @private\n */\nIntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\n  var margins = this._rootMarginValues.map(function(margin, i) {\n    return margin.unit == 'px' ? margin.value :\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\n  });\n  var newRect = {\n    top: rect.top - margins[0],\n    right: rect.right + margins[1],\n    bottom: rect.bottom + margins[2],\n    left: rect.left - margins[3]\n  };\n  newRect.width = newRect.right - newRect.left;\n  newRect.height = newRect.bottom - newRect.top;\n\n  return newRect;\n};\n\n\n/**\n * Accepts an old and new entry and returns true if at least one of the\n * threshold values has been crossed.\n * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\n *    particular target element or null if no previous entry exists.\n * @param {IntersectionObserverEntry} newEntry The current entry for a\n *    particular target element.\n * @return {boolean} Returns true if a any threshold has been crossed.\n * @private\n */\nIntersectionObserver.prototype._hasCrossedThreshold =\n    function(oldEntry, newEntry) {\n\n  // To make comparing easier, an entry that has a ratio of 0\n  // but does not actually intersect is given a value of -1\n  var oldRatio = oldEntry && oldEntry.isIntersecting ?\n      oldEntry.intersectionRatio || 0 : -1;\n  var newRatio = newEntry.isIntersecting ?\n      newEntry.intersectionRatio || 0 : -1;\n\n  // Ignore unchanged ratios\n  if (oldRatio === newRatio) return;\n\n  for (var i = 0; i < this.thresholds.length; i++) {\n    var threshold = this.thresholds[i];\n\n    // Return true if an entry matches a threshold or if the new ratio\n    // and the old ratio are on the opposite sides of a threshold.\n    if (threshold == oldRatio || threshold == newRatio ||\n        threshold < oldRatio !== threshold < newRatio) {\n      return true;\n    }\n  }\n};\n\n\n/**\n * Returns whether or not the root element is an element and is in the DOM.\n * @return {boolean} True if the root element is an element and is in the DOM.\n * @private\n */\nIntersectionObserver.prototype._rootIsInDom = function() {\n  return !this.root || docElement.contains(this.root);\n};\n\n\n/**\n * Returns whether or not the target element is a child of root.\n * @param {Element} target The target element to check.\n * @return {boolean} True if the target element is a child of root.\n * @private\n */\nIntersectionObserver.prototype._rootContainsTarget = function(target) {\n  return (this.root || docElement).contains(target);\n};\n\n\n/**\n * Adds the instance to the global IntersectionObserver registry if it isn't\n * already present.\n * @private\n */\nIntersectionObserver.prototype._registerInstance = function() {\n  if (registry.indexOf(this) < 0) {\n    registry.push(this);\n  }\n};\n\n\n/**\n * Removes the instance from the global IntersectionObserver registry.\n * @private\n */\nIntersectionObserver.prototype._unregisterInstance = function() {\n  var index = registry.indexOf(this);\n  if (index != -1) registry.splice(index, 1);\n};\n\n\n/**\n * Returns the result of the performance.now() method or null in browsers\n * that don't support the API.\n * @return {number} The elapsed time since the page was requested.\n */\nfunction now() {\n  return window.performance && performance.now && performance.now();\n}\n\n\n/**\n * Throttles a function and delays its executiong, so it's only called at most\n * once within a given time period.\n * @param {Function} fn The function to throttle.\n * @param {number} timeout The amount of time that must pass before the\n *     function can be called again.\n * @return {Function} The throttled function.\n */\nfunction throttle(fn, timeout) {\n  var timer = null;\n  return function () {\n    if (!timer) {\n      timer = setTimeout(function() {\n        fn();\n        timer = null;\n      }, timeout);\n    }\n  };\n}\n\n\n/**\n * Adds an event handler to a DOM node ensuring cross-browser compatibility.\n * @param {Node} node The DOM node to add the event handler to.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to add.\n * @param {boolean} opt_useCapture Optionally adds the even to the capture\n *     phase. Note: this only works in modern browsers.\n */\nfunction addEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.addEventListener == 'function') {\n    node.addEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.attachEvent == 'function') {\n    node.attachEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Removes a previously added event handler from a DOM node.\n * @param {Node} node The DOM node to remove the event handler from.\n * @param {string} event The event name.\n * @param {Function} fn The event handler to remove.\n * @param {boolean} opt_useCapture If the event handler was added with this\n *     flag set to true, it should be set to true here in order to remove it.\n */\nfunction removeEvent(node, event, fn, opt_useCapture) {\n  if (typeof node.removeEventListener == 'function') {\n    node.removeEventListener(event, fn, opt_useCapture || false);\n  }\n  else if (typeof node.detatchEvent == 'function') {\n    node.detatchEvent('on' + event, fn);\n  }\n}\n\n\n/**\n * Returns the intersection between two rect objects.\n * @param {Object} rect1 The first rect.\n * @param {Object} rect2 The second rect.\n * @return {?Object} The intersection rect or undefined if no intersection\n *     is found.\n */\nfunction computeRectIntersection(rect1, rect2) {\n  var top = Math.max(rect1.top, rect2.top);\n  var bottom = Math.min(rect1.bottom, rect2.bottom);\n  var left = Math.max(rect1.left, rect2.left);\n  var right = Math.min(rect1.right, rect2.right);\n  var width = right - left;\n  var height = bottom - top;\n\n  return (width >= 0 && height >= 0) && {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n\n\n/**\n * Shims the native getBoundingClientRect for compatibility with older IE.\n * @param {Element} el The element whose bounding rect to get.\n * @return {Object} The (possibly shimmed) rect of the element.\n */\nfunction getBoundingClientRect(el) {\n  var rect = el.getBoundingClientRect();\n  if (!rect) return;\n\n  // Older IE\n  if (!rect.width || !rect.height) {\n    rect = {\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  }\n  return rect;\n}\n\n\n/**\n * Returns an empty rect object. An empty rect is returned when an element\n * is not in the DOM.\n * @return {Object} The empty rect.\n */\nfunction getEmptyRect() {\n  return {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    width: 0,\n    height: 0\n  };\n}\n\n\n// Exposes the constructors globally.\nwindow.IntersectionObserver = IntersectionObserver;\nwindow.IntersectionObserverEntry = IntersectionObserverEntry;\n\n}(window, document));\n"],"names":["window","document","IntersectionObserverEntry","entry","time","target","rootBounds","boundingClientRect","intersectionRect","getEmptyRect","isIntersecting","targetRect","this","targetArea","width","height","intersectionArea","intersectionRatio","IntersectionObserver","callback","opt_options","options","Error","root","nodeType","_checkForIntersections","throttle","bind","THROTTLE_TIMEOUT","_callback","_observationTargets","_queuedEntries","_rootMarginValues","_parseRootMargin","rootMargin","thresholds","_initThresholds","threshold","map","margin","value","unit","join","now","performance","fn","timeout","timer","setTimeout","addEvent","node","event","opt_useCapture","addEventListener","attachEvent","removeEvent","removeEventListener","detatchEvent","computeRectIntersection","rect1","rect2","top","Math","max","bottom","min","left","right","getBoundingClientRect","el","rect","prototype","docElement","documentElement","registry","POLL_INTERVAL","observe","some","item","element","_registerInstance","push","_monitorIntersections","unobserve","filter","length","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","slice","opt_threshold","Array","isArray","sort","t","i","a","isNaN","opt_rootMargin","marginString","margins","split","parts","exec","parseFloat","_monitoringIntersections","_monitoringInterval","setInterval","_domObserver","MutationObserver","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","forEach","rootContainsTarget","_rootContainsTarget","oldEntry","_computeTargetAndRootIntersection","newEntry","_hasCrossedThreshold","getComputedStyle","display","parent","parentNode","atRoot","parentRect","overflow","html","body","clientWidth","clientHeight","_expandRectByRootMargin","newRect","oldRatio","newRatio","contains","indexOf","index","splice"],"mappings":"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"}