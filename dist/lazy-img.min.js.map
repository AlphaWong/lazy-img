{"version":3,"file":"lazy-img.min.js","sources":["../src/lazy-img.js"],"sourcesContent":["'use strict';\n\nlet polyfillPromise;\nif ('IntersectionObserver' in window &&\n    'IntersectionObserverEntry' in window &&\n    'intersectionRatio' in IntersectionObserverEntry.prototype) {\n  // Minimal polyfill for Edge 15's lack of `isIntersecting`\n  // See: https://github.com/WICG/IntersectionObserver/issues/211\n  if (!('isIntersecting' in IntersectionObserverEntry.prototype)) {\n    Object.defineProperty(IntersectionObserverEntry.prototype, 'isIntersecting', {\n      get: function () {\n        return this.intersectionRatio > 0;\n      }\n    });\n  }\n  polyfillPromise = Promise.resolve();\n} else {\n  const url = new URL('intersection-observer.js', document.currentScript.src);\n  polyfillPromise = new Promise(function(resolve, reject) {\n    var s = document.createElement(\"script\");\n    s.src = url.href;\n    s.onload = resolve;\n    s.onerror = reject;\n    document.head.appendChild(s);\n  });\n}\n\nvar elementObservers = new WeakMap();\n\nfunction notifyEntries(entries) {\n  for(var i = 0; i < entries.length; i++) {\n    var entry = entries[i];\n    if (entry.intersectionRatio) {\n      entry.target.loadImage();\n    }\n  }\n}\n\n// small blank image to use as placeholder\nconst blankSrc = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\n/**\n * `lazy-img` is a lazy loading img element that is shadow-dom friendly and uses\n * [IntersectionObserver](https://developers.google.com/web/updates/2016/04/intersectionobserver)\n * to efficiently detect when images are within the selected viewport and need to\n * be loaded.\n *\n * The default behavior is to use the browser viewport but more specific control\n * can be provided by setting the `observe` property to a parent selector (either\n * an element id, class or tag name):\n *\n * ```html\n * <div id=\"myscroller\">\n *   <lazy-img src=\"image1.jpg\" observe=\"#myscroller\"></lazy-img>\n *   <lazy-img src=\"image2.jpg\" observe=\"#myscroller\"></lazy-img>\n *   ...\n *   <lazy-img src=\"image99.jpg\" observe=\"#myscroller\"></lazy-img>\n * <div>\n * ```\n *\n * `margin` and `threshold` properties also allow control over exactly when loading\n * is triggered as the element comes into view. `margin` can reduce or extend the\n * detection area of the container and `threshold` can determine what proportion of\n * the image needs to be within the area.\n *\n * If used on a browser without support for `IntersectionObserver` a polyfill will\n * be loaded automatically.\n *\n * @customElement\n * @demo /components/lazy-img/demo/\n */\nclass LazyImgElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return ['alt', 'src', 'margin', 'threshold', 'observe'];\n  }\n\n  constructor() {\n    super();\n\n    this.shadow = this.attachShadow({ mode: 'open' });\n    this._img = document.createElement('img');\n    this._img.style.width = '100%';\n    this._img.style.height = '100%';\n    this._img.src = blankSrc;\n    this.shadow.appendChild(this._img);\n\n    this._margin =  '0px 0px 0px 0px';\n    this._threshold = 0.10;\n    this._observe = null;\n  }\n\n  connectedCallback() {\n    this.style.display = 'inline-block';\n  }\n\n  disconnectedCallback() {\n    this.stopObserving();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (oldValue === newValue) return;\n    this[name] = newValue;\n  }\n\n  /** image src. */\n  get src() { return this._src; }\n  set src(value) {\n    this.stopObserving();\n    this.removeAttribute('loaded');\n    this._src = value;\n    this._img.src = blankSrc;\n    this.startObserving();\n    this.setAttribute('src', value);\n  }\n\n  /** image alt text. */\n  get alt() { return this._alt; }\n  set alt(value) {\n    this._alt = this._img.alt = value;\n    this.setAttribute('alt', value);\n  }\n\n  /** margin to extend intersection observer. */\n  get margin() { return this._margin; }\n  set margin(value) {\n    this._margin = value;\n    this.setAttribute('margin', value);\n  }\n\n  /**\n   * threshold for intersection observer - what\n   * percentage of the image needs to be visible\n   * to trigger loading.\n   */\n  get threshold() { return this._threshold; }\n  set threshold(value) {\n    this._threshold = value;\n    this.setAttribute('threshold', value);\n  }\n\n  /** selector of the container element to observe. */\n  get observe() { return this._observe; }\n  set observe(value) {\n    this._observe = value;\n    this.setAttribute('observe', value);\n  }\n\n  /** load the image */\n  loadImage() {\n    this._img.onload = () => {\n      this.setAttribute('loaded', '');\n      var event = new Event('load');\n      event.detail = { originalTarget : this._img };\n      this.dispatchEvent(event);\n    };\n    this._img.src = this._src;\n    this.stopObserving();\n  }\n\n  /** stop observing visibility changes to this element */\n  stopObserving() {\n    if (this._observer) {\n      this._observer.unobserve(this);\n      if (--this._observer._lazyImgCount <= 0) {\n        this.deleteObserver(this._observer);\n      }\n      this._observer = null;\n    }\n  }\n\n  /** start observing for this element becoming visible */\n  startObserving() {\n    this.getObserver().then(observer => {\n      this._observer = observer;\n      this._observer.observe(this);\n      this._observer._lazyImgCount++;\n    });\n  }\n\n  /**\n   * get or create the observer for this element\n   *\n   * returns a promise so that IntersectionObserver\n   * can be polyfilled asynchronously and everything\n   * be wired up and created while that happens.\n   */\n  getObserver() {\n    return polyfillPromise.then(() => {\n      var observer;\n\n      // get element based on selector if there is one\n      var el = this._observe ? this.getClosest() : null;\n      var node = el || document.body;\n\n      var options = {\n        root: el,\n        rootMargin: this._margin,\n        threshold: this._threshold\n      }\n      // See if there is already an observer created for the\n      // intersection options given. Note we perform a double\n      // lookup (map within a map) because the actual map key\n      // is a different instance and there is no hashing\n      var observersMap = elementObservers.get(node);\n      if (!observersMap) {\n        observersMap = new Map();\n        elementObservers.set(node, observersMap);\n      }\n\n      var key = options.rootMargin + '/' + options.threshold;\n      observer = observersMap.get(key);\n      if (!observer) {\n        // first time for this observer options combination\n        observer = new IntersectionObserver(notifyEntries, options);\n        observer._lazyImgKey = key;\n        observer._lazyImgCount = 0;\n        observersMap.set(key, observer);\n      };\n\n      return observer;\n    });\n  }\n\n  /** disconnect and delete an observer */\n  deleteObserver(observer) {\n    var observersMap = elementObservers.get(observer.root);\n    if (observersMap) {\n      observersMap.delete(observer._lazyImgKey);\n      if (observersMap.size === 0) {\n        elementObservers.delete(observer.root);\n      }\n    }\n    observer.disconnect();\n  }\n\n  /** get the closest element with the given selector */\n  getClosest() {\n    var el = this;\n    while (el.host || (el.matches && !el.matches(this._observe)))\n      el = el.host || el.parentNode;\n    return el.matches ? el : null;\n  }\n}\n\nwindow.customElements.define('lazy-img', LazyImgElement);\n"],"names":["notifyEntries","entries","i","length","entry","intersectionRatio","target","loadImage","polyfillPromise","window","IntersectionObserverEntry","prototype","defineProperty","this","Promise","resolve","url","URL","document","currentScript","src","reject","s","createElement","href","onload","onerror","head","appendChild","elementObservers","WeakMap","blankSrc","LazyImgElement","shadow","_this","attachShadow","mode","_img","style","width","height","_margin","_threshold","_observe","display","stopObserving","name","oldValue","newValue","setAttribute","event","Event","detail","originalTarget","_this2","dispatchEvent","_src","_observer","unobserve","_lazyImgCount","deleteObserver","getObserver","then","observer","observe","el","_this4","getClosest","node","body","options","observersMap","get","Map","set","key","rootMargin","threshold","IntersectionObserver","_lazyImgKey","root","delete","size","disconnect","host","matches","parentNode","value","removeAttribute","startObserving","_alt","alt","HTMLElement","customElements","define"],"mappings":"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"}