{"version":3,"file":"lazy-img.es6.js","sources":["../src/lazy-img.js"],"sourcesContent":["'use strict';\n\nvar elementObservers = new WeakMap();\n\nfunction notifyEntries(entries) {\n  for(var i = 0; i < entries.length; i++) {\n    var entry = entries[i];\n    if (entry.intersectionRatio) {\n      entry.target.loadImage();\n    }\n  }\n}\n\nconst blankSrc = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\nlet polyfillPromise;\nif ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\n  polyfillPromise = Promise.resolve();\n} else {\n  const url = new URL('intersection-observer.js', document.currentScript.src);\n  polyfillPromise = new Promise(function(resolve, reject) {\n    var s = document.createElement(\"script\");\n    s.src = url.href;\n    s.onload = resolve;\n    s.onerror = reject;\n    document.documentElement.appendChild(s);\n  });\n}\n\nclass LazyImgElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return ['src', 'alt', 'margin', 'threshold', 'observe'];\n  }\n\n  constructor() {\n    super();\n\n    this.shadow = this.attachShadow({ mode: 'open' });\n    this.img = document.createElement('img');\n    this.img.style.width = '100%';\n    this.img.style.height = '100%';\n    this.img.src = blankSrc;\n    this.shadow.appendChild(this.img);\n\n    this.margin =  '0px 0px 0px 0px';\n    this.threshold = 0.10;\n    this.observe = null;\n  }\n\n  connectedCallback() {\n    this.style.display = 'inline-block';\n  }\n\n  disconnectedCallback() {\n    this.stopObserving();\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (oldValue === newValue) return;\n    switch (name) {\n      case 'alt':\n        this.img.alt = newValue;\n        break;\n      case 'src':\n        this.onSrcChanged(newValue);\n        break;\n      case 'margin':\n        this.margin = newValue;\n        break;\n      case 'threshold':\n        this.threshold = newValue;\n        break;\n      case 'observe':\n        this.observe = newValue;\n        break;\n    }\n  }\n\n  /** setting or changing the image src resets the state */\n  onSrcChanged(src) {\n    this.stopObserving();\n    this.removeAttribute('loaded');\n    this._src = src;\n    this.img.src = blankSrc;\n    this.startObserving();\n  }\n\n  /** load the image */\n  loadImage() {\n    this.img.onload = () => {\n      this.setAttribute('loaded', '');\n    };\n    this.img.src = this._src;\n    this.stopObserving();\n  }\n\n  /** stop observing visibility changes to this element */\n  stopObserving() {\n    if (this.observer) {\n      this.observer.unobserve(this);\n      if (--this.observer._lazyImgCount <= 0) {\n        this.deleteObserver(this.observer);\n      }\n      this.observer = null;\n    }\n  }\n\n  /** start observing for this element becoming visible */\n  startObserving() {\n    this.getObserver().then(observer => {\n      this.observer = observer;\n      this.observer.observe(this);\n      this.observer._lazyImgCount++;\n    });\n  }\n\n  /**\n   * get or create the observer for this element\n   *\n   * returns a promise so that IntersectionObserver\n   * can be polyfilled asynchronously and everything\n   * be wired up and created while that happens.\n   */\n  getObserver() {\n    return polyfillPromise.then(() => {\n      var observer;\n\n      // get element based on selector if there is one\n      var el = this.observe ? this.getClosest() : null;\n      var node = el || document.documentElement;\n\n      var options = {\n        root: el,\n        rootMargin: this.margin,\n        threshold: this.threshold\n      }\n      // See if there is already an observer created for the\n      // intersection options given. Note we perform a double\n      // lookup (map within a map) because the actual map key\n      // is a different instance and there is no hashing\n      var observersMap = elementObservers.get(node);\n      if (!observersMap) {\n        observersMap = new Map();\n        elementObservers.set(node, observersMap);\n      }\n\n      var key = options.rootMargin + '/' + options.threshold;\n      observer = observersMap.get(key);\n      if (!observer) {\n        // first time for this observer options combination\n        observer = new IntersectionObserver(notifyEntries, options);\n        observer._lazyImgKey = key;\n        observer._lazyImgCount = 0;\n        observersMap.set(key, observer);\n      };\n\n      return observer;\n    });\n  }\n\n  /** disconnect and delete an observer */\n  deleteObserver(observer) {\n    var observersMap = elementObservers.get(observer.root);\n    if (observersMap) {\n      observersMap.delete(observer._lazyImgKey);\n      if (observersMap.size === 0) {\n        elementObservers.delete(observer.root);\n      }\n    }\n    observer.disconnect();\n  }\n\n  /** get the closest element with the given selector */\n  getClosest() {\n    var el = this;\n    while (el.host || (el.matches && !el.matches(this.observe)))\n      el = el.host || el.parentNode;\n    return el.matches ? el : null;\n  }\n}\n\nwindow.customElements.define('lazy-img', LazyImgElement);\n"],"names":["notifyEntries","entries","i","length","entry","intersectionRatio","target","loadImage","elementObservers","WeakMap","blankSrc","polyfillPromise","window","IntersectionObserverEntry","prototype","Promise","resolve","url","URL","document","currentScript","src","reject","s","createElement","href","onload","onerror","documentElement","appendChild","LazyImgElement","HTMLElement","shadow","this","attachShadow","mode","img","style","width","height","margin","threshold","observe","display","stopObserving","name","oldValue","newValue","alt","onSrcChanged","removeAttribute","_src","startObserving","setAttribute","observer","unobserve","_lazyImgCount","deleteObserver","getObserver","then","el","getClosest","node","options","observersMap","get","Map","set","key","rootMargin","IntersectionObserver","_lazyImgKey","root","delete","size","disconnect","host","matches","parentNode","customElements","define"],"mappings":"wBAIA,SAASA,GAAcC,OACjB,GAAIC,GAAI,EAAGA,EAAID,EAAQE,OAAQD,IAAK,IAClCE,GAAQH,EAAQC,EAChBE,GAAMC,qBACFC,OAAOC,aANnB,GAAIC,GAAmB,GAAIC,QAW3B,MAAMC,GAAW,gFAEjB,IAAIC,EACJ,IAAI,wBAA0BC,SAAU,6BAA+BA,SAAU,qBAAuBA,QAAOC,0BAA0BC,YACrHC,QAAQC,cACrB,MACCC,GAAM,GAAIC,KAAI,2BAA4BC,SAASC,cAAcC,OACrD,GAAIN,SAAQ,SAASC,EAASM,MAC1CC,GAAIJ,SAASK,cAAc,YAC7BH,IAAMJ,EAAIQ,OACVC,OAASV,IACTW,QAAUL,WACHM,gBAAgBC,YAAYN,UAInCO,UAAuBC,oDAGjB,MAAO,MAAO,SAAU,YAAa,sCAMxCC,OAASC,KAAKC,cAAeC,KAAM,cACnCC,IAAMjB,SAASK,cAAc,YAC7BY,IAAIC,MAAMC,MAAQ,YAClBF,IAAIC,MAAME,OAAS,YACnBH,IAAIf,IAAMX,OACVsB,OAAOH,YAAYI,KAAKG,UAExBI,OAAU,uBACVC,UAAY,QACZC,QAAU,8BAIVL,MAAMM,QAAU,2CAIhBC,yCAGkBC,EAAMC,EAAUC,MACnCD,IAAaC,SACTF,OACD,WACET,IAAIY,IAAMD,YAEZ,WACEE,aAAaF,aAEf,cACEP,OAASO,YAEX,iBACEN,UAAYM,YAEd,eACEL,QAAUK,gBAMR1B,QACNuB,qBACAM,gBAAgB,eAChBC,KAAO9B,OACPe,IAAIf,IAAMX,OACV0C,kCAKAhB,IAAIV,kBACF2B,aAAa,SAAU,WAEzBjB,IAAIf,IAAMY,KAAKkB,UACfP,gCAKDX,KAAKqB,gBACFA,SAASC,UAAUtB,QAClBA,KAAKqB,SAASE,eAAiB,QAC9BC,eAAexB,KAAKqB,eAEtBA,SAAW,4BAMbI,cAAcC,KAAKL,SACjBA,SAAWA,OACXA,SAASZ,QAAQT,WACjBqB,SAASE,sCAYT7C,GAAgBgD,aACjBL,GAGAM,EAAK3B,KAAKS,QAAUT,KAAK4B,aAAe,KACxCC,EAAOF,GAAMzC,SAASS,gBAEtBmC,QACIH,aACM3B,KAAKO,iBACNP,KAAKQ,WAMduB,EAAexD,EAAiByD,IAAIH,EACnCE,OACY,GAAIE,OACFC,IAAIL,EAAME,OAGzBI,GAAML,EAAQM,WAAa,IAAMN,EAAQtB,mBAClCuB,EAAaC,IAAIG,GACvBd,MAEQ,GAAIgB,sBAAqBtE,EAAe+D,KAC1CQ,YAAcH,IACdZ,cAAgB,IACZW,IAAIC,EAAKd,IAGjBA,mBAKIA,MACTU,GAAexD,EAAiByD,IAAIX,EAASkB,KAC7CR,OACWS,OAAOnB,EAASiB,aACH,IAAtBP,EAAaU,QACED,OAAOnB,EAASkB,SAG5BG,iCAKLf,GAAK3B,KACF2B,EAAGgB,MAAShB,EAAGiB,UAAYjB,EAAGiB,QAAQ5C,KAAKS,UAChDkB,EAAKA,EAAGgB,MAAQhB,EAAGkB,iBACdlB,GAAGiB,QAAUjB,EAAK,MAI7BhD,OAAOmE,eAAeC,OAAO,WAAYlD"}